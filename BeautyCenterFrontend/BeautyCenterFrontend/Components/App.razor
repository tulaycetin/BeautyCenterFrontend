<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    <title>Güzellik Merkezi Yönetim Sistemi</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="app.css" />
    <link rel="stylesheet" href="BeautyCenterFrontend.styles.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <HeadOutlet />
</head>

<body>
    <Routes />
    <script src="_framework/blazor.web.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        window.showToast = (title, message, type) => {
            try {
                // Simple toast notification with error handling
                const toastContainer = document.getElementById('toast-container') || createToastContainer();
                const toast = document.createElement('div');
                toast.className = `toast show align-items-center text-white bg-${type} border-0`;
                toast.setAttribute('role', 'alert');
                toast.innerHTML = `
                    <div class="d-flex">
                        <div class="toast-body">
                            <strong>${title}</strong><br/>${message}
                        </div>
                        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                    </div>
                `;
                toastContainer.appendChild(toast);
                
                setTimeout(() => {
                    try {
                        if (toast && toast.parentNode) {
                            toast.remove();
                        }
                    } catch (e) {
                        console.log('Toast removal error (safe to ignore):', e);
                    }
                }, 5000);
                
                return true;
            } catch (error) {
                console.log('Toast creation error (safe to ignore):', error);
                return false;
            }
        };
        
        function createToastContainer() {
            const container = document.createElement('div');
            container.id = 'toast-container';
            container.className = 'toast-container position-fixed top-0 end-0 p-3';
            container.style.zIndex = '1050';
            document.body.appendChild(container);
            return container;
        }

        // Safe modal operations
        window.showModal = (modalId) => {
            try {
                const modalElement = document.getElementById(modalId);
                if (!modalElement) {
                    console.error(`Modal element with id '${modalId}' not found`);
                    return false;
                }

                // Remove tabindex that might prevent inputs from being focusable
                modalElement.removeAttribute('tabindex');
                
                // Ensure all form controls are enabled and focusable
                const formControls = modalElement.querySelectorAll('input, select, textarea, button');
                formControls.forEach(control => {
                    control.removeAttribute('tabindex');
                    control.removeAttribute('readonly');
                    control.style.pointerEvents = 'auto';
                    if (control.type !== 'submit' && control.type !== 'button') {
                        control.disabled = false;
                    }
                });
                
                // Check if modal is already open
                const existingModal = bootstrap.Modal.getInstance(modalElement);
                if (existingModal) {
                    console.log(`Modal '${modalId}' is already open`);
                    return true;
                }

                // Create new modal instance with focus enabled
                const modal = new bootstrap.Modal(modalElement, {
                    backdrop: true,
                    keyboard: true,
                    focus: false  // Disable automatic focus to prevent conflicts
                });
                modal.show();
                
                // Ensure form inputs can be focused after modal is shown
                modalElement.addEventListener('shown.bs.modal', function() {
                    // Remove any focus-blocking attributes
                    const allInputs = modalElement.querySelectorAll('input, select, textarea, button');
                    allInputs.forEach(input => {
                        input.removeAttribute('tabindex');
                        input.style.pointerEvents = 'auto';
                        input.disabled = false;
                    });
                    
                    // Focus first input after a longer delay
                    const firstInput = modalElement.querySelector('input[type="text"], input[type="email"], input[type="tel"], select, textarea');
                    if (firstInput) {
                        setTimeout(() => {
                            firstInput.removeAttribute('readonly');
                            firstInput.focus();
                            firstInput.click();
                        }, 200);
                    }
                }, { once: true });
                
                console.log(`Modal '${modalId}' opened successfully`);
                return true;
            } catch (error) {
                console.error(`Error opening modal '${modalId}':`, error);
                return false;
            }
        };

        window.hideModal = (modalId) => {
            try {
                const modalElement = document.getElementById(modalId);
                if (!modalElement) {
                    console.error(`Modal element with id '${modalId}' not found`);
                    return false;
                }

                const modalInstance = bootstrap.Modal.getInstance(modalElement);
                if (modalInstance) {
                    modalInstance.hide();
                    console.log(`Modal '${modalId}' closed successfully`);
                    return true;
                } else {
                    console.log(`Modal '${modalId}' is not open`);
                    return false;
                }
            } catch (error) {
                console.error(`Error closing modal '${modalId}':`, error);
                return false;
            }
        };

        window.switchModal = (fromModalId, toModalId) => {
            try {
                // First hide the current modal
                const success1 = window.hideModal(fromModalId);
                
                // Wait a bit for the first modal to close, then open the second one
                setTimeout(() => {
                    const success2 = window.showModal(toModalId);
                    console.log(`Modal switch from '${fromModalId}' to '${toModalId}': ${success1 && success2 ? 'success' : 'failed'}`);
                }, 300); // 300ms delay for smooth transition
                
                return true;
            } catch (error) {
                console.error(`Error switching modals from '${fromModalId}' to '${toModalId}':`, error);
                return false;
            }
        };

        // Clear form validation state
        window.clearFormValidation = (formId) => {
            try {
                const form = document.getElementById(formId) || document.querySelector(`form[name="${formId}"]`);
                if (!form) {
                    console.error(`Form with id or name '${formId}' not found`);
                    return false;
                }

                // Remove validation classes and messages
                const validationMessages = form.querySelectorAll('.validation-message');
                validationMessages.forEach(msg => {
                    msg.textContent = '';
                    msg.style.display = 'none';
                });

                // Remove validation classes from inputs
                const inputs = form.querySelectorAll('input, select, textarea');
                inputs.forEach(input => {
                    input.classList.remove('is-invalid', 'is-valid', 'invalid', 'valid', 'modified');
                });

                console.log(`Form validation cleared for '${formId}'`);
                return true;
            } catch (error) {
                console.error(`Error clearing form validation for '${formId}':`, error);
                return false;
            }
        };

        // Global error handlers to suppress Blazor Server interop errors
        window.addEventListener('error', function(e) {
            if (e.message && (
                e.message.includes('No interop methods are registered') ||
                e.message.includes('JSDisconnectedException') ||
                e.message.includes('circuit') ||
                e.message.includes('renderer')
            )) {
                console.log('Blazor Server disconnection error suppressed:', e.message);
                e.preventDefault();
                return false;
            }
        });

        window.addEventListener('unhandledrejection', function(e) {
            if (e.reason && e.reason.toString && (
                e.reason.toString().includes('JSDisconnectedException') ||
                e.reason.toString().includes('No interop methods') ||
                e.reason.toString().includes('circuit')
            )) {
                console.log('Blazor Server promise rejection suppressed:', e.reason);
                e.preventDefault();
                return false;
            }
        });

        // Override console.error for Blazor-specific errors
        const originalConsoleError = console.error;
        console.error = function() {
            const message = Array.from(arguments).join(' ');
            if (message.includes('No interop methods are registered') ||
                message.includes('JSDisconnectedException') ||
                message.includes('circuit') && message.includes('renderer') ||
                message.includes('blazor.web.js') ||
                message.includes('dispatchGlobalEventToAllElements') ||
                message.includes('onGlobalEvent')) {
                // Completely suppress these errors
                return;
            }
            originalConsoleError.apply(console, arguments);
        };

        // Hook into Blazor's error reporting mechanism
        window.addEventListener('DOMContentLoaded', function() {
            if (window.Blazor) {
                // Override Blazor's error handler
                const originalOnError = window.Blazor.onError;
                window.Blazor.onError = function(error) {
                    const errorMessage = error.toString();
                    if (errorMessage.includes('No interop methods') ||
                        errorMessage.includes('JSDisconnectedException') ||
                        errorMessage.includes('circuit') ||
                        errorMessage.includes('renderer')) {
                        // Suppress the error
                        return;
                    }
                    if (originalOnError) {
                        originalOnError(error);
                    }
                };
            }
        });

        // Monkey patch the Blazor framework to suppress specific errors
        (function() {
            const originalFetch = window.fetch;
            window.fetch = function(...args) {
                return originalFetch.apply(this, args).catch(error => {
                    if (error.message && (
                        error.message.includes('circuit') ||
                        error.message.includes('JSDisconnectedException')
                    )) {
                        // Suppress these network errors
                        return Promise.reject(new Error('Network error suppressed'));
                    }
                    return Promise.reject(error);
                });
            };
        })();

        // More aggressive error suppression - override the Error constructor
        const OriginalError = window.Error;
        window.Error = function(message) {
            if (typeof message === 'string' && (
                message.includes('No interop methods') ||
                message.includes('JSDisconnectedException') ||
                message.includes('circuit') ||
                message.includes('blazor.web.js')
            )) {
                // Create a dummy error that won't be logged
                const dummyError = Object.create(Error.prototype);
                dummyError.message = '';
                dummyError.name = 'SuppressedError';
                dummyError.stack = '';
                return dummyError;
            }
            return new OriginalError(message);
        };

        // Override all console methods to filter Blazor errors
        ['log', 'warn', 'error', 'info', 'debug'].forEach(method => {
            const original = console[method];
            console[method] = function() {
                const message = Array.from(arguments).join(' ');
                if (message.includes('blazor.web.js') ||
                    message.includes('dispatchGlobalEventToAllElements') ||
                    message.includes('onGlobalEvent') ||
                    message.includes('No interop methods') ||
                    message.includes('JSDisconnectedException')) {
                    return; // Suppress completely
                }
                original.apply(console, arguments);
            };
        });
    </script>
</body>

</html>
